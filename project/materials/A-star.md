# Объяснение кода

1. Библиотека heapq используется для реализации приоритетной очереди, что позволяет эффективно извлекать элемент с наименьшим приоритетом.

2. Эта функция вычисляет манхэттенское расстояние между двумя точками. Манхэттенское расстояние — это сумма абсолютных разностей по каждой координате, что подходит для сеток, где можно двигаться только по горизонтали и вертикали.

```python
def manhattan_distance(point1, point2):
    return abs(point1[0] - point2[0]) + abs(point1[1] - point2[1])
```

3. Основная функция, реализующая алгоритм A*. Она принимает на вход сетку (grid), стартовую точку (start) и целевую точку (goal).

```python
cost = {start: 0}
came_from = {start: None}
priority_queue = [(0, start)]
```

- cost: Словарь, хранящий стоимость достижения каждой точки.
- came_from: Словарь, хранящий информацию о том, откуда пришли в каждую точку.
- priority_queue: Приоритетная очередь для хранения точек и их оценок.

4. Цикл продолжается до тех пор, пока есть элементы в очереди. Извлекается точка с наименьшей стоимостью.

```python
while priority_queue:
    current_cost, current_point = heapq.heappop(priority_queue)
    if current_point == goal:
        break
```

5. Для каждой соседней точки проверяется её доступность (не выходит ли за границы сетки и не является ли препятствием).
Если новая стоимость меньше уже известной стоимости для этой точки или её ещё нет в словаре cost, обновляются значения и добавляется новая точка в очередь.

```python
for neighbor in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
    x, y = current_point[0] + neighbor[0], current_point[1] + neighbor[1]
    new_cost = cost[current_point] + 1 
    if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] == 0:
        if (x, y) not in cost or new_cost < cost[(x, y)]:
            cost[(x, y)] = new_cost
            priority = new_cost + manhattan_distance((x, y), goal)  
            heapq.heappush(priority_queue, (priority, (x, y)))
            came_from[(x, y)] = current_point
```

## Обработка соседей в алгоритме A*

Обработка соседей — это ключевая часть алгоритма A*, которая позволяет исследовать возможные пути от текущей точки до соседних. Давайте рассмотрим этот процесс более подробно.

### Основной цикл обработки соседей

Внутри основного цикла алгоритма A* (после извлечения текущей точки из приоритетной очереди) происходит обработка всех соседних точек:

```python
for neighbor in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
    x, y = current_point[0] + neighbor[0], current_point[1] + neighbor[1]
```

#### Соседние точки

Соседние точки определяются с помощью смещений:
- `(1, 0)`: движение вправо
- `(-1, 0)`: движение влево
- `(0, 1)`: движение вниз
- `(0, -1)`: движение вверх

Каждое смещение добавляется к текущей точке (`current_point`), чтобы получить координаты соседней точки `(x, y)`.

### Проверка доступности соседей

После вычисления координат соседней точки необходимо проверить, доступна ли она для перемещения:

```python
if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] == 0:
```

#### Условия проверки:
1. **Проверка границ сетки**:
   - `0 <= x < len(grid)`: проверяет, что `x` находится в пределах высоты сетки.
   - `0 <= y < len(grid)`: проверяет, что `y` находится в пределах ширины сетки.

2. **Проверка на препятствие**:
   - `grid[x][y] == 0`: проверяет, что клетка не является препятствием (в данном случае `1` обозначает препятствие, а `0` — проходимую клетку).

### Вычисление новой стоимости

Если соседняя точка доступна, вычисляется новая стоимость достижения этой точки:

```python
new_cost = cost[current_point] + 1
```

- Здесь предполагается, что перемещение на одну клетку стоит `1`. Таким образом, новая стоимость равна стоимости текущей клетки плюс `1`.

### Сравнение и обновление стоимости

Далее происходит сравнение новой стоимости с уже известной стоимостью для этой соседней точки:

```python
if (x, y) not in cost or new_cost < cost[(x, y)]:
```

#### Условия проверки:
- **Проверка на наличие в словаре**: 
  - `(x, y) not in cost` — если эта точка ещё не была посещена.
  
- **Сравнение стоимостей**: 
  - `new_cost < cost[(x, y)]` — если новая стоимость меньше уже известной.

Если одно из условий выполняется, то обновляются значения:

```python
cost[(x, y)] = new_cost
priority = new_cost + manhattan_distance((x, y), goal)
heapq.heappush(priority_queue, (priority, (x, y)))
came_from[(x, y)] = current_point
```

### Обновление значений

1. **Обновление стоимости**:
   - `cost[(x, y)] = new_cost`: сохраняет новую стоимость для соседней клетки.

2. **Вычисление приоритета**:
   - `priority = new_cost + manhattan_distance((x, y), goal)`: вычисляет общую оценку для приоритетной очереди. Она состоит из фактической стоимости до текущей клетки и эвристической оценки расстояния до цели.

3. **Добавление в приоритетную очередь**:
   - `heapq.heappush(priority_queue, (priority, (x, y)))`: добавляет новую точку и её приоритет в очередь.

4. **Сохранение пути**:
   - `came_from[(x, y)] = current_point`: сохраняет информацию о том, откуда пришли в эту клетку. Это необходимо для восстановления пути после завершения поиска.

---

6. После нахождения целевой точки восстанавливается путь от цели к началу с помощью словаря came_from.

```python
path = []
current = goal
while current:
    path.append(current)
    current = came_from[current]
path.reverse()
return path 
```

7. Задаётся функция main

```python
def main():
    grid = [
        [0, 0, 0, 0, 0],
        [0, 1, 1, 0, 0],
        [0, 0, 0, 1, 0],
        [0, 1, 0, 0, 0],
        [0, 0, 0, 0, 0]
    ]

    start = (0, 0)
    goal = (4, 4)
    result_path = astar(grid, start, goal)

    print("Путь от A до B:")
    for point in result_path:
        print(point)

if __name__ == '__main__':
    main()
```

---
